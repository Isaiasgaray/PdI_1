ACTIVIDAD: Desarrolle una función para implementar la ecualización local del histograma, 
que reciba como parámetros de entrada la imagen a procesar, y el tamaño de la 
ventana de procesamiento (M x N). Utilice dicha función para analizar la imagen que 
se muestra en Fig. 1 e informe cuales son los detalles escondidos en las diferentes 
zonas de la misma. Analice la influencia del tamaño de la ventana en los resultados
obtenidos.

RESOLUCION: 
Creamos una funcion llamada ecualizacion_local_histograma que tiene como parametros la imagen original mas el 
tamaño de la ventana. Dentro de la funcion vamos a declarar una variable mida_ventana que va a dividir en dos 
el tañano de la venta, la variable mitad_ventana la vamos a usar como parametro en la funcion copyMakeBorder
para determinar los pixeles que le vamos a agregar como borde a la imagen original en sus cuatro borde,
es necesario agregar borde a la imagen original para poder centrar la ventana de eculizacion en los bordes 
latereales de la imagen original, la funcion copyMakeBorder tiene un parametro importe que es borderType en 
este parametro nosotros elegimos por ejemplo si queremos replicar los valores laterales que tenemos en la imagen 
original en los pixeles que agregamos en la ventana otra opcion es rellenarlas con ceros, en nuestro casos usamos 
REPLICATE para replicar los valores.
En imagen_resultado se va a crear una matriz del tamaño de la imagen vacia.
Vamos a realizar un for anidad para ir recorriendo pixel a pixel la imagen original, dentro del for 
vamos a ir creando una ventana pixel a pixel para por realizar la ecualizacion local del histograma y
en imagen resultado se va a guardar pixel por pixel el valor dado por la ecualizacion. La funcion va a 
retornar la imagen ecualizada.
Dentro del for vamos a tener la funcion cv2.calcHist que la vamos a usar para calular el histograma de la 
ventan, la funcion cumsum() que calcula la funcion de distribucion acumulada del histograma, despues vamos 
a normalizar el histograma para asegurarnos que los rangos de los pixeles de la imagen de salida esten en
0 255, despues a la pixel de salida(en la imagen resultado) le vamos a dar el valor que le corresponde en la
funcion de distribucion acumulada. 
IMPORTANTE: Probamos con la funcion cv2.equalizeHist que hace todo lo mismo que lo comentado arriba y
notamos una mejoria importe en la rapidez del codigo, como tambien asi podemos decir que si usamos 
la funcion np.histogram para calcular el histograma el codigo era aun mas lento.

Al final vamos a mostrar la eculizacion local con diferentes tamaño de la ventana y podremos observar
diferentes resultados, estos resultados se deben a que segun el tamaño de la ventana vamos a tomar mas 
pixeles del fondo o menos, ademas hay que tener encuneta que la imagen tiene ruido. Nosotros mostramos 
tres tamaños de ventana para observar diferentes resultado, si el tamaño de la ventana es muy chico no 
vamos a obtener el resultado querido podemos ver como no se "suaviza" bien la imagen y hay partes en 
donde la imagen tiene pixeles en cero o 255. Con una ventana adeduaca se puede ver la imagen mucho mejor 
ya que se lleva los valores a pixels mas escaldo quiero decir que donde un pixel con una ventanda chica 
toma un valor blanco aca en la ventana adecuada el pixil va a tener un valor gris y esto tambien va a 
si la ventana es muy grande donde los valores se va ir mas hacia el cero. 






